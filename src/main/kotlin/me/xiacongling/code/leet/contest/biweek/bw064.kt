package me.xiacongling.code.leet.contest.biweek

import me.xiacongling.code.leet.Difficulty
import me.xiacongling.code.leet.Solution

@Solution(
    id = 5898, title = "数组中第 K 个独一无二的字符", difficulty = Difficulty.EASY, description = """
独一无二的字符串指的是在一个数组中只出现过一次的字符串。

给你一个字符串数组 arr 和一个整数k，请你返回arr中第k个独一无二的字符串。
如果少于k个独一无二的字符串，那么返回空字符串 ""。

注意，按照字符串在原数组中的 顺序找到第 k个独一无二字符串。

示例 1:
输入：arr = ["d","b","c","b","c","a"], k = 2
输出："a"
解释：
arr 中独一无二字符串包括 "d" 和 "a"。
"d" 首先出现，所以它是第 1 个独一无二字符串。
"a" 第二个出现，所以它是 2 个独一无二字符串。
由于 k == 2 ，返回 "a" 。

示例 2:
输入：arr = ["aaa","aa","a"], k = 1
输出："aaa"
解释：
arr 中所有字符串都是独一无二的，所以返回第 1 个字符串 "aaa" 。

示例 3：
输入：arr = ["a","b","a"], k = 3
输出：""
解释：
唯一一个独一无二字符串是 "b" 。由于少于 3 个独一无二字符串，我们返回空字符串 "" 。

提示：
* 1 <= k <= arr.length <= 1000
* 1 <= arr[i].length <= 5
* arr[i]只包含小写英文字母。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/kth-distinct-string-in-an-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
"""
)
fun kthDistinct(arr: Array<String>, k: Int): String {
    return arr.groupingBy { it }
        .eachCount()
        .filterValues { it < 2 }
        .map { it.key }
        .getOrElse(k - 1) { "" }
}

@Solution(
    id = 5899, title = "两个最好的不重叠活动", difficulty = Difficulty.MEDIUM, description = """
给你一个下标从 0 开始的二维整数数组 events，其中 events[i] = [startTime_i, endTime_i, value_i]。
第i个活动开始于 startTime_i，结束于 endTime_i，如果你参加这个活动，那么你可以得到价值 value_i。
你最多可以参加两个时间不重叠活动，使得它们的价值之和最大。

请你返回价值之和的最大值。

注意，活动的开始时间和结束时间是 包括在活动时间内的，也就是说，你不能参加两个活动且它们之一的开始时间等于另一个活动的
结束时间。更具体的，如果你参加一个活动，且结束时间为 t，那么下一个活动必须在 t + 1 或之后的时间开始。

示例 1:

  Time  |--- 1 ---|--- 2 ---|--- 3 ---|--- 4 ---|--- 5 ---|
Event 0 |------------- 2 -------------|                   |
Event 1 |                             |-------- 2 --------|
Event 2 |         |-------------- 3 ------------|         |

输入：events = [[1,3,2],[4,5,2],[2,4,3]]
输出：4
解释：选择绿色的活动 0 和 1 ，价值之和为 2 + 2 = 4 。

示例 2：

  Time  |--- 1 ---|--- 2 ---|--- 3 ---|--- 4 ---|--- 5 ---|
Event 0 |------------- 2 -------------|                   |
Event 1 |                             |-------- 2 --------|
Event 2 |----------------------- 5 -----------------------|

输入：events = [[1,3,2],[4,5,2],[1,5,5]]
输出：5
解释：选择活动 2 ，价值和为 5 。

示例 3：

  Time  |--- 1 ---|--- 2 ---|--- 3 ---|--- 4 ---|--- 5 ---|
Event 0 |------------------ 3 ------------------|         |
Event 1 |------------------ 1 ------------------|         |
Event 2 |                                       |--- 5 ---|

输入：events = [[1,5,3],[1,5,1],[6,6,5]]
输出：8
解释：选择活动 0 和 2 ，价值之和为 3 + 5 = 8 。

提示：
* 2 <= events.length <= 10^5
* events[i].length == 3
* 1 <= startTime_i <= endTime_i <= 10^9
* 1 <= value_i <= 10^6

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-best-non-overlapping-events
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
"""
)
fun maxTwoEvents(events: Array<IntArray>): Int {
    fun overlap(x: IntArray, y: IntArray): Boolean {
        return x[0] <= y[0] && x[1] >= y[0] || y[0] <= x[0] && y[1] >= x[0]
    }

    // todo: TLE
    val n = events.size
    var m = events.maxOf { it[2] }
    for (i in 0 until n) {
        for (j in (i + 1) until n) {
            val ei = events[i]
            val ej = events[j]
            val v = ei[2] + ej[2]
            if (!overlap(ei, ej) && v > m) {
                m = v
            }
        }
    }
    return m
}

@Solution(
    id = 5900, title = "蜡烛之间的盘子", difficulty = Difficulty.MEDIUM, description = """
给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 0 开始的字符串 s，它只包含字符 '*' 和 '|' ，
其中 '*' 表示一个 盘子 ，'|' 表示一支蜡烛。

同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] 表示子字符串 
s[lefti...righti]（包含左右端点的字符）。对于每个查询，你需要找到 子字符串中在两支蜡烛之间的盘子的数目。
如果一个盘子在子字符串中左边和右边都至少有一支蜡烛，那么这个盘子满足在两支蜡烛之间。

* 比方说，s = "||**||**|*"，查询 [3, 8]，表示的是子字符串 "*||**|"。子字符串中在两支蜡烛之间的
  盘子数目为 2，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。

请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。

示例 1:
                      0  1  2  3  4  5  6  7  8  9
                  s:  *  *  |  *  *  |  *  *  *  |
queries[0] = [2, 5]:        |  *  *  |
queries[1] = [5, 9]:                 |  *  *  *  |

输入：s = "**|**|***|", queries = [[2,5],[5,9]]
输出：[2,3]
解释：
- queries[0] 有两个盘子在蜡烛之间。
- queries[1] 有三个盘子在蜡烛之间。

示例 2:

                       0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0
                   s:  *  *  *  |  *  *  |  *  *  *  *  *  |  *  *  |  |  *  *  |  *
queries[0] = [1, 17]:     *  *  |  *  *  |  *  *  *  *  *  |  *  *  |  |  *
queries[1] = [ 4, 5]:     *  * 
queries[2] = [14,17]:                                            *  |  |  *
queries[3] = [5, 11]:                 *  |  *  *  *  *  *
queries[4] = [15,16]:                                               |  |

输入：s = "***|**|*****|**||**|*", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]
输出：[9,0,0,0,0]
解释：
- queries[0] 有 9 个盘子在蜡烛之间。
- 另一个查询没有盘子在蜡烛之间。

提示：
* 3 <= s.length <= 10^5
* s 只包含字符 '*' 和 '|' 。
* 1 <= queries.length <= 10^5
* queries[i].length == 2
* 0 <= left_i <= right_i < s.length

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/plates-between-candles
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
"""
)
fun platesBetweenCandles(s: String, queries: Array<IntArray>): IntArray {
    // todo
    return intArrayOf()
}

@Solution(
    id = 5901, title = "", difficulty = Difficulty.HARD, description = """
有一个 8 x 8 的棋盘，它包含 n 个棋子（棋子包括车，后和象三种）。给你一个长度为 n 的字符串数组 pieces，
其中 pieces[i] 表示第 i 个棋子的类型（车，后或象）。除此以外，还给你一个长度为 n 的二维整数数组 positions，
其中 positions[i] = [ri, ci] 表示第 i 个棋子现在在棋盘上的位置为 (ri, ci) ，棋盘下标从 1 开始。

棋盘上每个棋子都可以移动至多一次。每个棋子的移动中，首先选择移动的方向，然后选择移动的步数，同时你要确保
移动过程中棋子不能移到棋盘以外的地方。棋子需按照以下规则移动：

* 车可以 水平或者竖直 从 (r, c) 沿着方向 (r+1, c)，(r-1, c)，(r, c+1) 或者 (r, c-1) 移动。
* 后可以 水平竖直或者斜对角 从 (r, c) 沿着方向 (r+1, c)，(r-1, c)，(r, c+1)，(r, c-1)，
  (r+1, c+1)，(r+1, c-1)，(r-1, c+1)，(r-1, c-1) 移动。
* 象可以 斜对角 从 (r, c) 沿着方向 (r+1, c+1)，(r+1, c-1)，(r-1, c+1)，(r-1, c-1) 移动。

移动组合 包含所有棋子的 移动 。每一秒，每个棋子都沿着它们选择的方向往前移动 一步 ，直到它们到达目标位置。
所有棋子从时刻 0 开始移动。如果在某个时刻，两个或者更多棋子占据了同一个格子，那么这个移动组合 不有效 。

请你返回 有效 移动组合的数目。

注意：
* 初始时，不会有两个棋子 在 同一个位置 。
* 有可能在一个移动组合中，有棋子不移动。
* 如果两个棋子 直接相邻 且两个棋子下一秒要互相占据对方的位置，可以将它们在同一秒内 交换位置 。
 

示例 1:
+---+---+---+---+---+---+---+---+
| R | * | * | * | * | * | * | * |
+---+---+---+---+---+---+---+---+
| * |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| * |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| * |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| * |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| * |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| * |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| * |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+

输入：pieces = ["rook"], positions = [[1,1]]
输出：15
解释：上图展示了棋子所有可能的移动。

示例 2：
+---+---+---+---+---+---+---+---+
| Q | * | * | * | * | * | * | * |
+---+---+---+---+---+---+---+---+
| * | * |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| * |   | * |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| * |   |   | * |   |   |   |   |
+---+---+---+---+---+---+---+---+
| * |   |   |   | * |   |   |   |
+---+---+---+---+---+---+---+---+
| * |   |   |   |   | * |   |   |
+---+---+---+---+---+---+---+---+
| * |   |   |   |   |   | * |   |
+---+---+---+---+---+---+---+---+
| * |   |   |   |   |   |   | * |
+---+---+---+---+---+---+---+---+

输入：pieces = ["queen"], positions = [[1,1]]
输出：22
解释：上图展示了棋子所有可能的移动。

示例 3:
+---+---+---+---+---+---+---+---+
|   |   |   |   |   | * |   |   |
+---+---+---+---+---+---+---+---+
| * |   |   |   | * |   |   |   |
+---+---+---+---+---+---+---+---+
|   | * |   | * |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   | B |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   | * |   | * |   |   |   |   |
+---+---+---+---+---+---+---+---+
| * |   |   |   | * |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   | * |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   | * |   |
+---+---+---+---+---+---+---+---+
输入：pieces = ["bishop"], positions = [[4,3]]
输出：12
解释：上图展示了棋子所有可能的移动。

示例 4:
+---+---+---+---+---+---+---+---+
| R | * | * | * | * | * | * | * |
+---+---+---+---+---+---+---+---+
| * |   |   |   |   |   |   | * |
+---+---+---+---+---+---+---+---+
| * |   |   |   |   |   |   | * |
+---+---+---+---+---+---+---+---+
| * |   |   |   |   |   |   | * |
+---+---+---+---+---+---+---+---+
| * |   |   |   |   |   |   | * |
+---+---+---+---+---+---+---+---+
| * |   |   |   |   |   |   | * |
+---+---+---+---+---+---+---+---+
| * |   |   |   |   |   |   | * |
+---+---+---+---+---+---+---+---+
| * | * | * | * | * | * | * | R |
+---+---+---+---+---+---+---+---+

输入：pieces = ["rook","rook"], positions = [[1,1],[8,8]]
输出：223
解释：每个车有 15 种移动，所以总共有 15 * 15 = 225 种移动组合。
但是，有两个是不有效的移动组合：
- 将两个车都移动到 (8, 1) ，会导致它们在同一个格子相遇。
- 将两个车都移动到 (1, 8) ，会导致它们在同一个格子相遇。
所以，总共有 225 - 2 = 223 种有效移动组合。
注意，有两种有效的移动组合，分别是一个车在 (1, 8) ，另一个车在 (8, 1) 。
即使棋盘状态是相同的，这两个移动组合被视为不同的，因为每个棋子移动操作是不相同的。

示例 5：
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   | B |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   | Q |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+

输入：pieces = ["queen","bishop"], positions = [[5,7],[3,4]]
输出：281
解释：总共有 12 * 24 = 288 种移动组合。
但是，有一些不有效的移动组合：
- 如果后停在 (6, 7) ，它会阻挡象到达 (6, 7) 或者 (7, 8) 。
- 如果后停在 (5, 6) ，它会阻挡象到达 (5, 6) ，(6, 7) 或者 (7, 8) 。
- 如果象停在 (5, 2) ，它会阻挡后到达 (5, 2) 或者 (5, 1) 。
在 288 个移动组合当中，281 个是有效的。
 

提示：
* n == pieces.length
* n == positions.length
* 1 <= n <= 4
* pieces 只包含字符串 "rook" ，"queen" 和 "bishop" 。
* 棋盘上总共最多只有一个后。
* 1 <= x_i, y_i <= 8
* 每一个 positions[i] 互不相同。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/number-of-valid-move-combinations-on-chessboard
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
"""
)
fun countCombinations(pieces: Array<String>, positions: Array<IntArray>): Int {
    // todo
    return 0
}